// This file was generated by ./generate.pl

package event // import "github.com/octo/ghbot/event"

import (
	"context"
	"fmt"
	"log"
	"sync"

	"github.com/google/go-github/github"
	"go.opencensus.io/trace"
)

// Handle handles a webhook event.
func Handle(ctx context.Context, event interface{}) error {
	switch event := event.(type) {
	case *github.CheckRunEvent:
		return handleCheckRun(ctx, event)
	case *github.CheckSuiteEvent:
		return handleCheckSuite(ctx, event)
	case *github.CommitCommentEvent:
		return handleCommitComment(ctx, event)
	case *github.CreateEvent:
		return handleCreate(ctx, event)
	case *github.DeleteEvent:
		return handleDelete(ctx, event)
	case *github.DeploymentEvent:
		return handleDeployment(ctx, event)
	case *github.DeploymentStatusEvent:
		return handleDeploymentStatus(ctx, event)
	case *github.ForkEvent:
		return handleFork(ctx, event)
	case *github.GollumEvent:
		return handleGollum(ctx, event)
	case *github.InstallationEvent:
		return handleInstallation(ctx, event)
	case *github.InstallationRepositoriesEvent:
		return handleInstallationRepositories(ctx, event)
	case *github.IssueCommentEvent:
		return handleIssueComment(ctx, event)
	case *github.IssueEvent:
		return handleIssue(ctx, event)
	case *github.IssuesEvent:
		return handleIssues(ctx, event)
	case *github.LabelEvent:
		return handleLabel(ctx, event)
	case *github.MarketplacePurchaseEvent:
		return handleMarketplacePurchase(ctx, event)
	case *github.MemberEvent:
		return handleMember(ctx, event)
	case *github.MembershipEvent:
		return handleMembership(ctx, event)
	case *github.MilestoneEvent:
		return handleMilestone(ctx, event)
	case *github.OrganizationEvent:
		return handleOrganization(ctx, event)
	case *github.OrgBlockEvent:
		return handleOrgBlock(ctx, event)
	case *github.PageBuildEvent:
		return handlePageBuild(ctx, event)
	case *github.ProjectCardEvent:
		return handleProjectCard(ctx, event)
	case *github.ProjectColumnEvent:
		return handleProjectColumn(ctx, event)
	case *github.ProjectEvent:
		return handleProject(ctx, event)
	case *github.PublicEvent:
		return handlePublic(ctx, event)
	case *github.PullRequestEvent:
		return handlePullRequest(ctx, event)
	case *github.PullRequestReviewEvent:
		return handlePullRequestReview(ctx, event)
	case *github.PullRequestReviewCommentEvent:
		return handlePullRequestReviewComment(ctx, event)
	case *github.PushEvent:
		return handlePush(ctx, event)
	case *github.ReleaseEvent:
		return handleRelease(ctx, event)
	case *github.RepositoryEvent:
		return handleRepository(ctx, event)
	case *github.StatusEvent:
		return handleStatus(ctx, event)
	case *github.TeamAddEvent:
		return handleTeamAdd(ctx, event)
	case *github.TeamEvent:
		return handleTeam(ctx, event)
	case *github.WatchEvent:
		return handleWatch(ctx, event)
	default:
		log.Printf("unimplemented event type: %T", event)
	}

	return nil
}

//
// CheckRun events
//
var checkRunHandlers = map[string]func(context.Context, *github.CheckRunEvent) error{}

// CheckRunHandler registers a handler for CheckRun events.
func CheckRunHandler(name string, hndl func(context.Context, *github.CheckRunEvent) error) {
	checkRunHandlers[name] = hndl
}

// handleCheckRun calls all handlers for CheckRun events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCheckRun(ctx context.Context, event *github.CheckRunEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event CheckRun")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "CheckRun"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range checkRunHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CheckRunEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q CheckRun handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// CheckSuite events
//
var checkSuiteHandlers = map[string]func(context.Context, *github.CheckSuiteEvent) error{}

// CheckSuiteHandler registers a handler for CheckSuite events.
func CheckSuiteHandler(name string, hndl func(context.Context, *github.CheckSuiteEvent) error) {
	checkSuiteHandlers[name] = hndl
}

// handleCheckSuite calls all handlers for CheckSuite events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCheckSuite(ctx context.Context, event *github.CheckSuiteEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event CheckSuite")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "CheckSuite"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range checkSuiteHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CheckSuiteEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q CheckSuite handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// CommitComment events
//
var commitCommentHandlers = map[string]func(context.Context, *github.CommitCommentEvent) error{}

// CommitCommentHandler registers a handler for CommitComment events.
func CommitCommentHandler(name string, hndl func(context.Context, *github.CommitCommentEvent) error) {
	commitCommentHandlers[name] = hndl
}

// handleCommitComment calls all handlers for CommitComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCommitComment(ctx context.Context, event *github.CommitCommentEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event CommitComment")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "CommitComment"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range commitCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CommitCommentEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q CommitComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Create events
//
var createHandlers = map[string]func(context.Context, *github.CreateEvent) error{}

// CreateHandler registers a handler for Create events.
func CreateHandler(name string, hndl func(context.Context, *github.CreateEvent) error) {
	createHandlers[name] = hndl
}

// handleCreate calls all handlers for Create events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCreate(ctx context.Context, event *github.CreateEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Create")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Create"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range createHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CreateEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Create handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Delete events
//
var deleteHandlers = map[string]func(context.Context, *github.DeleteEvent) error{}

// DeleteHandler registers a handler for Delete events.
func DeleteHandler(name string, hndl func(context.Context, *github.DeleteEvent) error) {
	deleteHandlers[name] = hndl
}

// handleDelete calls all handlers for Delete events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDelete(ctx context.Context, event *github.DeleteEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Delete")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Delete"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deleteHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeleteEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Delete handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Deployment events
//
var deploymentHandlers = map[string]func(context.Context, *github.DeploymentEvent) error{}

// DeploymentHandler registers a handler for Deployment events.
func DeploymentHandler(name string, hndl func(context.Context, *github.DeploymentEvent) error) {
	deploymentHandlers[name] = hndl
}

// handleDeployment calls all handlers for Deployment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeployment(ctx context.Context, event *github.DeploymentEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Deployment")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Deployment"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deploymentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeploymentEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Deployment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// DeploymentStatus events
//
var deploymentStatusHandlers = map[string]func(context.Context, *github.DeploymentStatusEvent) error{}

// DeploymentStatusHandler registers a handler for DeploymentStatus events.
func DeploymentStatusHandler(name string, hndl func(context.Context, *github.DeploymentStatusEvent) error) {
	deploymentStatusHandlers[name] = hndl
}

// handleDeploymentStatus calls all handlers for DeploymentStatus events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeploymentStatus(ctx context.Context, event *github.DeploymentStatusEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event DeploymentStatus")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "DeploymentStatus"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deploymentStatusHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeploymentStatusEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q DeploymentStatus handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Fork events
//
var forkHandlers = map[string]func(context.Context, *github.ForkEvent) error{}

// ForkHandler registers a handler for Fork events.
func ForkHandler(name string, hndl func(context.Context, *github.ForkEvent) error) {
	forkHandlers[name] = hndl
}

// handleFork calls all handlers for Fork events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleFork(ctx context.Context, event *github.ForkEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Fork")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Fork"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range forkHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ForkEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Fork handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Gollum events
//
var gollumHandlers = map[string]func(context.Context, *github.GollumEvent) error{}

// GollumHandler registers a handler for Gollum events.
func GollumHandler(name string, hndl func(context.Context, *github.GollumEvent) error) {
	gollumHandlers[name] = hndl
}

// handleGollum calls all handlers for Gollum events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleGollum(ctx context.Context, event *github.GollumEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Gollum")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Gollum"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range gollumHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.GollumEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Gollum handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Installation events
//
var installationHandlers = map[string]func(context.Context, *github.InstallationEvent) error{}

// InstallationHandler registers a handler for Installation events.
func InstallationHandler(name string, hndl func(context.Context, *github.InstallationEvent) error) {
	installationHandlers[name] = hndl
}

// handleInstallation calls all handlers for Installation events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleInstallation(ctx context.Context, event *github.InstallationEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Installation")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Installation"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range installationHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.InstallationEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Installation handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// InstallationRepositories events
//
var installationRepositoriesHandlers = map[string]func(context.Context, *github.InstallationRepositoriesEvent) error{}

// InstallationRepositoriesHandler registers a handler for InstallationRepositories events.
func InstallationRepositoriesHandler(name string, hndl func(context.Context, *github.InstallationRepositoriesEvent) error) {
	installationRepositoriesHandlers[name] = hndl
}

// handleInstallationRepositories calls all handlers for InstallationRepositories events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleInstallationRepositories(ctx context.Context, event *github.InstallationRepositoriesEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event InstallationRepositories")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "InstallationRepositories"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range installationRepositoriesHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.InstallationRepositoriesEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q InstallationRepositories handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// IssueComment events
//
var issueCommentHandlers = map[string]func(context.Context, *github.IssueCommentEvent) error{}

// IssueCommentHandler registers a handler for IssueComment events.
func IssueCommentHandler(name string, hndl func(context.Context, *github.IssueCommentEvent) error) {
	issueCommentHandlers[name] = hndl
}

// handleIssueComment calls all handlers for IssueComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssueComment(ctx context.Context, event *github.IssueCommentEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event IssueComment")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "IssueComment"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range issueCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.IssueCommentEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q IssueComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Issue events
//
var issueHandlers = map[string]func(context.Context, *github.IssueEvent) error{}

// IssueHandler registers a handler for Issue events.
func IssueHandler(name string, hndl func(context.Context, *github.IssueEvent) error) {
	issueHandlers[name] = hndl
}

// handleIssue calls all handlers for Issue events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssue(ctx context.Context, event *github.IssueEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Issue")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Issue"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range issueHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.IssueEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Issue handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Issues events
//
var issuesHandlers = map[string]func(context.Context, *github.IssuesEvent) error{}

// IssuesHandler registers a handler for Issues events.
func IssuesHandler(name string, hndl func(context.Context, *github.IssuesEvent) error) {
	issuesHandlers[name] = hndl
}

// handleIssues calls all handlers for Issues events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssues(ctx context.Context, event *github.IssuesEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Issues")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Issues"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range issuesHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.IssuesEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Issues handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Label events
//
var labelHandlers = map[string]func(context.Context, *github.LabelEvent) error{}

// LabelHandler registers a handler for Label events.
func LabelHandler(name string, hndl func(context.Context, *github.LabelEvent) error) {
	labelHandlers[name] = hndl
}

// handleLabel calls all handlers for Label events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleLabel(ctx context.Context, event *github.LabelEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Label")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Label"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range labelHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.LabelEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Label handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// MarketplacePurchase events
//
var marketplacePurchaseHandlers = map[string]func(context.Context, *github.MarketplacePurchaseEvent) error{}

// MarketplacePurchaseHandler registers a handler for MarketplacePurchase events.
func MarketplacePurchaseHandler(name string, hndl func(context.Context, *github.MarketplacePurchaseEvent) error) {
	marketplacePurchaseHandlers[name] = hndl
}

// handleMarketplacePurchase calls all handlers for MarketplacePurchase events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMarketplacePurchase(ctx context.Context, event *github.MarketplacePurchaseEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event MarketplacePurchase")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "MarketplacePurchase"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range marketplacePurchaseHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MarketplacePurchaseEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q MarketplacePurchase handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Member events
//
var memberHandlers = map[string]func(context.Context, *github.MemberEvent) error{}

// MemberHandler registers a handler for Member events.
func MemberHandler(name string, hndl func(context.Context, *github.MemberEvent) error) {
	memberHandlers[name] = hndl
}

// handleMember calls all handlers for Member events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMember(ctx context.Context, event *github.MemberEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Member")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Member"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range memberHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MemberEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Member handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Membership events
//
var membershipHandlers = map[string]func(context.Context, *github.MembershipEvent) error{}

// MembershipHandler registers a handler for Membership events.
func MembershipHandler(name string, hndl func(context.Context, *github.MembershipEvent) error) {
	membershipHandlers[name] = hndl
}

// handleMembership calls all handlers for Membership events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMembership(ctx context.Context, event *github.MembershipEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Membership")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Membership"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range membershipHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MembershipEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Membership handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Milestone events
//
var milestoneHandlers = map[string]func(context.Context, *github.MilestoneEvent) error{}

// MilestoneHandler registers a handler for Milestone events.
func MilestoneHandler(name string, hndl func(context.Context, *github.MilestoneEvent) error) {
	milestoneHandlers[name] = hndl
}

// handleMilestone calls all handlers for Milestone events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMilestone(ctx context.Context, event *github.MilestoneEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Milestone")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Milestone"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range milestoneHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MilestoneEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Milestone handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Organization events
//
var organizationHandlers = map[string]func(context.Context, *github.OrganizationEvent) error{}

// OrganizationHandler registers a handler for Organization events.
func OrganizationHandler(name string, hndl func(context.Context, *github.OrganizationEvent) error) {
	organizationHandlers[name] = hndl
}

// handleOrganization calls all handlers for Organization events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleOrganization(ctx context.Context, event *github.OrganizationEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Organization")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Organization"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range organizationHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.OrganizationEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Organization handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// OrgBlock events
//
var orgBlockHandlers = map[string]func(context.Context, *github.OrgBlockEvent) error{}

// OrgBlockHandler registers a handler for OrgBlock events.
func OrgBlockHandler(name string, hndl func(context.Context, *github.OrgBlockEvent) error) {
	orgBlockHandlers[name] = hndl
}

// handleOrgBlock calls all handlers for OrgBlock events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleOrgBlock(ctx context.Context, event *github.OrgBlockEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event OrgBlock")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "OrgBlock"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range orgBlockHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.OrgBlockEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q OrgBlock handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PageBuild events
//
var pageBuildHandlers = map[string]func(context.Context, *github.PageBuildEvent) error{}

// PageBuildHandler registers a handler for PageBuild events.
func PageBuildHandler(name string, hndl func(context.Context, *github.PageBuildEvent) error) {
	pageBuildHandlers[name] = hndl
}

// handlePageBuild calls all handlers for PageBuild events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePageBuild(ctx context.Context, event *github.PageBuildEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event PageBuild")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "PageBuild"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pageBuildHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PageBuildEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PageBuild handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// ProjectCard events
//
var projectCardHandlers = map[string]func(context.Context, *github.ProjectCardEvent) error{}

// ProjectCardHandler registers a handler for ProjectCard events.
func ProjectCardHandler(name string, hndl func(context.Context, *github.ProjectCardEvent) error) {
	projectCardHandlers[name] = hndl
}

// handleProjectCard calls all handlers for ProjectCard events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleProjectCard(ctx context.Context, event *github.ProjectCardEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event ProjectCard")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "ProjectCard"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range projectCardHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ProjectCardEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q ProjectCard handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// ProjectColumn events
//
var projectColumnHandlers = map[string]func(context.Context, *github.ProjectColumnEvent) error{}

// ProjectColumnHandler registers a handler for ProjectColumn events.
func ProjectColumnHandler(name string, hndl func(context.Context, *github.ProjectColumnEvent) error) {
	projectColumnHandlers[name] = hndl
}

// handleProjectColumn calls all handlers for ProjectColumn events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleProjectColumn(ctx context.Context, event *github.ProjectColumnEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event ProjectColumn")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "ProjectColumn"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range projectColumnHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ProjectColumnEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q ProjectColumn handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Project events
//
var projectHandlers = map[string]func(context.Context, *github.ProjectEvent) error{}

// ProjectHandler registers a handler for Project events.
func ProjectHandler(name string, hndl func(context.Context, *github.ProjectEvent) error) {
	projectHandlers[name] = hndl
}

// handleProject calls all handlers for Project events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleProject(ctx context.Context, event *github.ProjectEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Project")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Project"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range projectHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ProjectEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Project handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Public events
//
var publicHandlers = map[string]func(context.Context, *github.PublicEvent) error{}

// PublicHandler registers a handler for Public events.
func PublicHandler(name string, hndl func(context.Context, *github.PublicEvent) error) {
	publicHandlers[name] = hndl
}

// handlePublic calls all handlers for Public events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePublic(ctx context.Context, event *github.PublicEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Public")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Public"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range publicHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PublicEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Public handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequest events
//
var pullRequestHandlers = map[string]func(context.Context, *github.PullRequestEvent) error{}

// PullRequestHandler registers a handler for PullRequest events.
func PullRequestHandler(name string, hndl func(context.Context, *github.PullRequestEvent) error) {
	pullRequestHandlers[name] = hndl
}

// handlePullRequest calls all handlers for PullRequest events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequest(ctx context.Context, event *github.PullRequestEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event PullRequest")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "PullRequest"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequest handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequestReview events
//
var pullRequestReviewHandlers = map[string]func(context.Context, *github.PullRequestReviewEvent) error{}

// PullRequestReviewHandler registers a handler for PullRequestReview events.
func PullRequestReviewHandler(name string, hndl func(context.Context, *github.PullRequestReviewEvent) error) {
	pullRequestReviewHandlers[name] = hndl
}

// handlePullRequestReview calls all handlers for PullRequestReview events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReview(ctx context.Context, event *github.PullRequestReviewEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event PullRequestReview")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "PullRequestReview"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestReviewHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestReviewEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequestReview handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequestReviewComment events
//
var pullRequestReviewCommentHandlers = map[string]func(context.Context, *github.PullRequestReviewCommentEvent) error{}

// PullRequestReviewCommentHandler registers a handler for PullRequestReviewComment events.
func PullRequestReviewCommentHandler(name string, hndl func(context.Context, *github.PullRequestReviewCommentEvent) error) {
	pullRequestReviewCommentHandlers[name] = hndl
}

// handlePullRequestReviewComment calls all handlers for PullRequestReviewComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReviewComment(ctx context.Context, event *github.PullRequestReviewCommentEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event PullRequestReviewComment")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "PullRequestReviewComment"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestReviewCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestReviewCommentEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequestReviewComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Push events
//
var pushHandlers = map[string]func(context.Context, *github.PushEvent) error{}

// PushHandler registers a handler for Push events.
func PushHandler(name string, hndl func(context.Context, *github.PushEvent) error) {
	pushHandlers[name] = hndl
}

// handlePush calls all handlers for Push events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePush(ctx context.Context, event *github.PushEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Push")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Push"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pushHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PushEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Push handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Release events
//
var releaseHandlers = map[string]func(context.Context, *github.ReleaseEvent) error{}

// ReleaseHandler registers a handler for Release events.
func ReleaseHandler(name string, hndl func(context.Context, *github.ReleaseEvent) error) {
	releaseHandlers[name] = hndl
}

// handleRelease calls all handlers for Release events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRelease(ctx context.Context, event *github.ReleaseEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Release")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Release"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range releaseHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ReleaseEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Release handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Repository events
//
var repositoryHandlers = map[string]func(context.Context, *github.RepositoryEvent) error{}

// RepositoryHandler registers a handler for Repository events.
func RepositoryHandler(name string, hndl func(context.Context, *github.RepositoryEvent) error) {
	repositoryHandlers[name] = hndl
}

// handleRepository calls all handlers for Repository events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRepository(ctx context.Context, event *github.RepositoryEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Repository")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Repository"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range repositoryHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.RepositoryEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Repository handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Status events
//
var statusHandlers = map[string]func(context.Context, *github.StatusEvent) error{}

// StatusHandler registers a handler for Status events.
func StatusHandler(name string, hndl func(context.Context, *github.StatusEvent) error) {
	statusHandlers[name] = hndl
}

// handleStatus calls all handlers for Status events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleStatus(ctx context.Context, event *github.StatusEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Status")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Status"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range statusHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.StatusEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Status handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// TeamAdd events
//
var teamAddHandlers = map[string]func(context.Context, *github.TeamAddEvent) error{}

// TeamAddHandler registers a handler for TeamAdd events.
func TeamAddHandler(name string, hndl func(context.Context, *github.TeamAddEvent) error) {
	teamAddHandlers[name] = hndl
}

// handleTeamAdd calls all handlers for TeamAdd events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleTeamAdd(ctx context.Context, event *github.TeamAddEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event TeamAdd")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "TeamAdd"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range teamAddHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.TeamAddEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q TeamAdd handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Team events
//
var teamHandlers = map[string]func(context.Context, *github.TeamEvent) error{}

// TeamHandler registers a handler for Team events.
func TeamHandler(name string, hndl func(context.Context, *github.TeamEvent) error) {
	teamHandlers[name] = hndl
}

// handleTeam calls all handlers for Team events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleTeam(ctx context.Context, event *github.TeamEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Team")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Team"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range teamHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.TeamEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Team handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Watch events
//
var watchHandlers = map[string]func(context.Context, *github.WatchEvent) error{}

// WatchHandler registers a handler for Watch events.
func WatchHandler(name string, hndl func(context.Context, *github.WatchEvent) error) {
	watchHandlers[name] = hndl
}

// handleWatch calls all handlers for Watch events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleWatch(ctx context.Context, event *github.WatchEvent) error {
	ctx, span := trace.StartSpan(ctx, "Event Watch")
	span.AddAttributes(
		trace.StringAttribute("/github/event", "Watch"),
	)
	defer span.End()

	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range watchHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.WatchEvent) error) {
			defer wg.Done()

			ctx, span := trace.StartSpan(ctx, "Action "+name)
			span.AddAttributes(
				trace.StringAttribute("/github/bot/action", name),
			)
			defer span.End()

			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Watch handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Print(lastErr)
		}
		lastErr = err
	}

	return lastErr
}
