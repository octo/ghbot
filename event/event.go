// This file was generated by ./generate.pl

package event // import "github.com/octo/ghbot/event"

import (
	"context"
	"fmt"
	"sync"

	"github.com/google/go-github/github"
	"google.golang.org/appengine/log"
)

// Handle handles a webhook event.
func Handle(ctx context.Context, event interface{}) error {
	switch event := event.(type) {
	case *github.CommitCommentEvent:
		return handleCommitComment(ctx, event)
	case *github.CreateEvent:
		return handleCreate(ctx, event)
	case *github.DeleteEvent:
		return handleDelete(ctx, event)
	case *github.DeploymentEvent:
		return handleDeployment(ctx, event)
	case *github.DeploymentStatusEvent:
		return handleDeploymentStatus(ctx, event)
	case *github.ForkEvent:
		return handleFork(ctx, event)
	case *github.GollumEvent:
		return handleGollum(ctx, event)
	case *github.IssueCommentEvent:
		return handleIssueComment(ctx, event)
	case *github.IssuesEvent:
		return handleIssues(ctx, event)
	case *github.LabelEvent:
		return handleLabel(ctx, event)
	case *github.MemberEvent:
		return handleMember(ctx, event)
	case *github.MembershipEvent:
		return handleMembership(ctx, event)
	case *github.MilestoneEvent:
		return handleMilestone(ctx, event)
	case *github.PageBuildEvent:
		return handlePageBuild(ctx, event)
	case *github.PublicEvent:
		return handlePublic(ctx, event)
	case *github.PullRequestEvent:
		return handlePullRequest(ctx, event)
	case *github.PullRequestReviewEvent:
		return handlePullRequestReview(ctx, event)
	case *github.PullRequestReviewCommentEvent:
		return handlePullRequestReviewComment(ctx, event)
	case *github.PushEvent:
		return handlePush(ctx, event)
	case *github.ReleaseEvent:
		return handleRelease(ctx, event)
	case *github.RepositoryEvent:
		return handleRepository(ctx, event)
	case *github.StatusEvent:
		return handleStatus(ctx, event)
	case *github.TeamAddEvent:
		return handleTeamAdd(ctx, event)
	case *github.WatchEvent:
		return handleWatch(ctx, event)
	default:
		log.Errorf(ctx, "unimplemented event type: %T", event)
	}

	return nil
}

//
// CommitComment events
//
var commitCommentHandlers = map[string]func(context.Context, *github.CommitCommentEvent) error{}

// CommitCommentHandler registers a handler for CommitComment events.
func CommitCommentHandler(name string, hndl func(context.Context, *github.CommitCommentEvent) error) {
	commitCommentHandlers[name] = hndl
}

// handleCommitComment calls all handlers for CommitComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCommitComment(ctx context.Context, event *github.CommitCommentEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range commitCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CommitCommentEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q CommitComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Create events
//
var createHandlers = map[string]func(context.Context, *github.CreateEvent) error{}

// CreateHandler registers a handler for Create events.
func CreateHandler(name string, hndl func(context.Context, *github.CreateEvent) error) {
	createHandlers[name] = hndl
}

// handleCreate calls all handlers for Create events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCreate(ctx context.Context, event *github.CreateEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range createHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.CreateEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Create handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Delete events
//
var deleteHandlers = map[string]func(context.Context, *github.DeleteEvent) error{}

// DeleteHandler registers a handler for Delete events.
func DeleteHandler(name string, hndl func(context.Context, *github.DeleteEvent) error) {
	deleteHandlers[name] = hndl
}

// handleDelete calls all handlers for Delete events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDelete(ctx context.Context, event *github.DeleteEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deleteHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeleteEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Delete handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Deployment events
//
var deploymentHandlers = map[string]func(context.Context, *github.DeploymentEvent) error{}

// DeploymentHandler registers a handler for Deployment events.
func DeploymentHandler(name string, hndl func(context.Context, *github.DeploymentEvent) error) {
	deploymentHandlers[name] = hndl
}

// handleDeployment calls all handlers for Deployment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeployment(ctx context.Context, event *github.DeploymentEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deploymentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeploymentEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Deployment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// DeploymentStatus events
//
var deploymentStatusHandlers = map[string]func(context.Context, *github.DeploymentStatusEvent) error{}

// DeploymentStatusHandler registers a handler for DeploymentStatus events.
func DeploymentStatusHandler(name string, hndl func(context.Context, *github.DeploymentStatusEvent) error) {
	deploymentStatusHandlers[name] = hndl
}

// handleDeploymentStatus calls all handlers for DeploymentStatus events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeploymentStatus(ctx context.Context, event *github.DeploymentStatusEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range deploymentStatusHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.DeploymentStatusEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q DeploymentStatus handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Fork events
//
var forkHandlers = map[string]func(context.Context, *github.ForkEvent) error{}

// ForkHandler registers a handler for Fork events.
func ForkHandler(name string, hndl func(context.Context, *github.ForkEvent) error) {
	forkHandlers[name] = hndl
}

// handleFork calls all handlers for Fork events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleFork(ctx context.Context, event *github.ForkEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range forkHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ForkEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Fork handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Gollum events
//
var gollumHandlers = map[string]func(context.Context, *github.GollumEvent) error{}

// GollumHandler registers a handler for Gollum events.
func GollumHandler(name string, hndl func(context.Context, *github.GollumEvent) error) {
	gollumHandlers[name] = hndl
}

// handleGollum calls all handlers for Gollum events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleGollum(ctx context.Context, event *github.GollumEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range gollumHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.GollumEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Gollum handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// IssueComment events
//
var issueCommentHandlers = map[string]func(context.Context, *github.IssueCommentEvent) error{}

// IssueCommentHandler registers a handler for IssueComment events.
func IssueCommentHandler(name string, hndl func(context.Context, *github.IssueCommentEvent) error) {
	issueCommentHandlers[name] = hndl
}

// handleIssueComment calls all handlers for IssueComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssueComment(ctx context.Context, event *github.IssueCommentEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range issueCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.IssueCommentEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q IssueComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Issues events
//
var issuesHandlers = map[string]func(context.Context, *github.IssuesEvent) error{}

// IssuesHandler registers a handler for Issues events.
func IssuesHandler(name string, hndl func(context.Context, *github.IssuesEvent) error) {
	issuesHandlers[name] = hndl
}

// handleIssues calls all handlers for Issues events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssues(ctx context.Context, event *github.IssuesEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range issuesHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.IssuesEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Issues handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Label events
//
var labelHandlers = map[string]func(context.Context, *github.LabelEvent) error{}

// LabelHandler registers a handler for Label events.
func LabelHandler(name string, hndl func(context.Context, *github.LabelEvent) error) {
	labelHandlers[name] = hndl
}

// handleLabel calls all handlers for Label events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleLabel(ctx context.Context, event *github.LabelEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range labelHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.LabelEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Label handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Member events
//
var memberHandlers = map[string]func(context.Context, *github.MemberEvent) error{}

// MemberHandler registers a handler for Member events.
func MemberHandler(name string, hndl func(context.Context, *github.MemberEvent) error) {
	memberHandlers[name] = hndl
}

// handleMember calls all handlers for Member events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMember(ctx context.Context, event *github.MemberEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range memberHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MemberEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Member handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Membership events
//
var membershipHandlers = map[string]func(context.Context, *github.MembershipEvent) error{}

// MembershipHandler registers a handler for Membership events.
func MembershipHandler(name string, hndl func(context.Context, *github.MembershipEvent) error) {
	membershipHandlers[name] = hndl
}

// handleMembership calls all handlers for Membership events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMembership(ctx context.Context, event *github.MembershipEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range membershipHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MembershipEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Membership handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Milestone events
//
var milestoneHandlers = map[string]func(context.Context, *github.MilestoneEvent) error{}

// MilestoneHandler registers a handler for Milestone events.
func MilestoneHandler(name string, hndl func(context.Context, *github.MilestoneEvent) error) {
	milestoneHandlers[name] = hndl
}

// handleMilestone calls all handlers for Milestone events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMilestone(ctx context.Context, event *github.MilestoneEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range milestoneHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.MilestoneEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Milestone handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PageBuild events
//
var pageBuildHandlers = map[string]func(context.Context, *github.PageBuildEvent) error{}

// PageBuildHandler registers a handler for PageBuild events.
func PageBuildHandler(name string, hndl func(context.Context, *github.PageBuildEvent) error) {
	pageBuildHandlers[name] = hndl
}

// handlePageBuild calls all handlers for PageBuild events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePageBuild(ctx context.Context, event *github.PageBuildEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pageBuildHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PageBuildEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PageBuild handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Public events
//
var publicHandlers = map[string]func(context.Context, *github.PublicEvent) error{}

// PublicHandler registers a handler for Public events.
func PublicHandler(name string, hndl func(context.Context, *github.PublicEvent) error) {
	publicHandlers[name] = hndl
}

// handlePublic calls all handlers for Public events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePublic(ctx context.Context, event *github.PublicEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range publicHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PublicEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Public handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequest events
//
var pullRequestHandlers = map[string]func(context.Context, *github.PullRequestEvent) error{}

// PullRequestHandler registers a handler for PullRequest events.
func PullRequestHandler(name string, hndl func(context.Context, *github.PullRequestEvent) error) {
	pullRequestHandlers[name] = hndl
}

// handlePullRequest calls all handlers for PullRequest events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequest(ctx context.Context, event *github.PullRequestEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequest handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequestReview events
//
var pullRequestReviewHandlers = map[string]func(context.Context, *github.PullRequestReviewEvent) error{}

// PullRequestReviewHandler registers a handler for PullRequestReview events.
func PullRequestReviewHandler(name string, hndl func(context.Context, *github.PullRequestReviewEvent) error) {
	pullRequestReviewHandlers[name] = hndl
}

// handlePullRequestReview calls all handlers for PullRequestReview events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReview(ctx context.Context, event *github.PullRequestReviewEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestReviewHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestReviewEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequestReview handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// PullRequestReviewComment events
//
var pullRequestReviewCommentHandlers = map[string]func(context.Context, *github.PullRequestReviewCommentEvent) error{}

// PullRequestReviewCommentHandler registers a handler for PullRequestReviewComment events.
func PullRequestReviewCommentHandler(name string, hndl func(context.Context, *github.PullRequestReviewCommentEvent) error) {
	pullRequestReviewCommentHandlers[name] = hndl
}

// handlePullRequestReviewComment calls all handlers for PullRequestReviewComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReviewComment(ctx context.Context, event *github.PullRequestReviewCommentEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pullRequestReviewCommentHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PullRequestReviewCommentEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q PullRequestReviewComment handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Push events
//
var pushHandlers = map[string]func(context.Context, *github.PushEvent) error{}

// PushHandler registers a handler for Push events.
func PushHandler(name string, hndl func(context.Context, *github.PushEvent) error) {
	pushHandlers[name] = hndl
}

// handlePush calls all handlers for Push events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePush(ctx context.Context, event *github.PushEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range pushHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.PushEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Push handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Release events
//
var releaseHandlers = map[string]func(context.Context, *github.ReleaseEvent) error{}

// ReleaseHandler registers a handler for Release events.
func ReleaseHandler(name string, hndl func(context.Context, *github.ReleaseEvent) error) {
	releaseHandlers[name] = hndl
}

// handleRelease calls all handlers for Release events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRelease(ctx context.Context, event *github.ReleaseEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range releaseHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.ReleaseEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Release handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Repository events
//
var repositoryHandlers = map[string]func(context.Context, *github.RepositoryEvent) error{}

// RepositoryHandler registers a handler for Repository events.
func RepositoryHandler(name string, hndl func(context.Context, *github.RepositoryEvent) error) {
	repositoryHandlers[name] = hndl
}

// handleRepository calls all handlers for Repository events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRepository(ctx context.Context, event *github.RepositoryEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range repositoryHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.RepositoryEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Repository handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Status events
//
var statusHandlers = map[string]func(context.Context, *github.StatusEvent) error{}

// StatusHandler registers a handler for Status events.
func StatusHandler(name string, hndl func(context.Context, *github.StatusEvent) error) {
	statusHandlers[name] = hndl
}

// handleStatus calls all handlers for Status events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleStatus(ctx context.Context, event *github.StatusEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range statusHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.StatusEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Status handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// TeamAdd events
//
var teamAddHandlers = map[string]func(context.Context, *github.TeamAddEvent) error{}

// TeamAddHandler registers a handler for TeamAdd events.
func TeamAddHandler(name string, hndl func(context.Context, *github.TeamAddEvent) error) {
	teamAddHandlers[name] = hndl
}

// handleTeamAdd calls all handlers for TeamAdd events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleTeamAdd(ctx context.Context, event *github.TeamAddEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range teamAddHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.TeamAddEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q TeamAdd handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}

//
// Watch events
//
var watchHandlers = map[string]func(context.Context, *github.WatchEvent) error{}

// WatchHandler registers a handler for Watch events.
func WatchHandler(name string, hndl func(context.Context, *github.WatchEvent) error) {
	watchHandlers[name] = hndl
}

// handleWatch calls all handlers for Watch events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleWatch(ctx context.Context, event *github.WatchEvent) error {
	wg := sync.WaitGroup{}
	ch := make(chan error)

	for name, hndl := range watchHandlers {
		wg.Add(1)

		go func(name string, hndl func(context.Context, *github.WatchEvent) error) {
			defer wg.Done()
			if err := hndl(ctx, event); err != nil {
				ch <- fmt.Errorf("%q Watch handler: %v", name, err)
			}
		}(name, hndl)
	}

	go func() {
		wg.Wait()
		close(ch)
	}()

	var lastErr error
	for err := range ch {
		if lastErr != nil {
			log.Errorf(ctx, "%v", lastErr)
		}
		lastErr = err
	}

	return lastErr
}
