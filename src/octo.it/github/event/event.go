// This file was generated by ./generate.pl

package event // import "octo.it/github/event"

import (
	"context"
	"log"

	"github.com/google/go-github/github"
)

// Handle handles a webhook event.
func Handle(ctx context.Context, event interface{}) error {
	switch event := event.(type) {
	case *github.CommitCommentEvent:
		return handleCommitComment(ctx, event)
	case *github.CreateEvent:
		return handleCreate(ctx, event)
	case *github.DeleteEvent:
		return handleDelete(ctx, event)
	case *github.DeploymentEvent:
		return handleDeployment(ctx, event)
	case *github.DeploymentStatusEvent:
		return handleDeploymentStatus(ctx, event)
	case *github.ForkEvent:
		return handleFork(ctx, event)
	case *github.GollumEvent:
		return handleGollum(ctx, event)
	case *github.IssueCommentEvent:
		return handleIssueComment(ctx, event)
	case *github.IssuesEvent:
		return handleIssues(ctx, event)
	case *github.LabelEvent:
		return handleLabel(ctx, event)
	case *github.MemberEvent:
		return handleMember(ctx, event)
	case *github.MembershipEvent:
		return handleMembership(ctx, event)
	case *github.MilestoneEvent:
		return handleMilestone(ctx, event)
	case *github.PageBuildEvent:
		return handlePageBuild(ctx, event)
	case *github.PublicEvent:
		return handlePublic(ctx, event)
	case *github.PullRequestEvent:
		return handlePullRequest(ctx, event)
	case *github.PullRequestReviewEvent:
		return handlePullRequestReview(ctx, event)
	case *github.PullRequestReviewCommentEvent:
		return handlePullRequestReviewComment(ctx, event)
	case *github.PushEvent:
		return handlePush(ctx, event)
	case *github.ReleaseEvent:
		return handleRelease(ctx, event)
	case *github.RepositoryEvent:
		return handleRepository(ctx, event)
	case *github.StatusEvent:
		return handleStatus(ctx, event)
	case *github.TeamAddEvent:
		return handleTeamAdd(ctx, event)
	case *github.WatchEvent:
		return handleWatch(ctx, event)
	default:
		log.Printf("unimplemented event type: %T", event)
	}

	return nil
}

//
// CommitComment events
//
var commitCommentHandlers []func(context.Context, *github.CommitCommentEvent) error

// CommitCommentHandler registers a handler for CommitComment events.
func CommitCommentHandler(hndl func(context.Context, *github.CommitCommentEvent) error) {
	commitCommentHandlers = append(commitCommentHandlers, hndl)
}

// handleCommitComment calls all handlers for CommitComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCommitComment(ctx context.Context, event *github.CommitCommentEvent) error {
	for _, hndl := range commitCommentHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Create events
//
var createHandlers []func(context.Context, *github.CreateEvent) error

// CreateHandler registers a handler for Create events.
func CreateHandler(hndl func(context.Context, *github.CreateEvent) error) {
	createHandlers = append(createHandlers, hndl)
}

// handleCreate calls all handlers for Create events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleCreate(ctx context.Context, event *github.CreateEvent) error {
	for _, hndl := range createHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Delete events
//
var deleteHandlers []func(context.Context, *github.DeleteEvent) error

// DeleteHandler registers a handler for Delete events.
func DeleteHandler(hndl func(context.Context, *github.DeleteEvent) error) {
	deleteHandlers = append(deleteHandlers, hndl)
}

// handleDelete calls all handlers for Delete events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDelete(ctx context.Context, event *github.DeleteEvent) error {
	for _, hndl := range deleteHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Deployment events
//
var deploymentHandlers []func(context.Context, *github.DeploymentEvent) error

// DeploymentHandler registers a handler for Deployment events.
func DeploymentHandler(hndl func(context.Context, *github.DeploymentEvent) error) {
	deploymentHandlers = append(deploymentHandlers, hndl)
}

// handleDeployment calls all handlers for Deployment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeployment(ctx context.Context, event *github.DeploymentEvent) error {
	for _, hndl := range deploymentHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// DeploymentStatus events
//
var deploymentStatusHandlers []func(context.Context, *github.DeploymentStatusEvent) error

// DeploymentStatusHandler registers a handler for DeploymentStatus events.
func DeploymentStatusHandler(hndl func(context.Context, *github.DeploymentStatusEvent) error) {
	deploymentStatusHandlers = append(deploymentStatusHandlers, hndl)
}

// handleDeploymentStatus calls all handlers for DeploymentStatus events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleDeploymentStatus(ctx context.Context, event *github.DeploymentStatusEvent) error {
	for _, hndl := range deploymentStatusHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Fork events
//
var forkHandlers []func(context.Context, *github.ForkEvent) error

// ForkHandler registers a handler for Fork events.
func ForkHandler(hndl func(context.Context, *github.ForkEvent) error) {
	forkHandlers = append(forkHandlers, hndl)
}

// handleFork calls all handlers for Fork events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleFork(ctx context.Context, event *github.ForkEvent) error {
	for _, hndl := range forkHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Gollum events
//
var gollumHandlers []func(context.Context, *github.GollumEvent) error

// GollumHandler registers a handler for Gollum events.
func GollumHandler(hndl func(context.Context, *github.GollumEvent) error) {
	gollumHandlers = append(gollumHandlers, hndl)
}

// handleGollum calls all handlers for Gollum events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleGollum(ctx context.Context, event *github.GollumEvent) error {
	for _, hndl := range gollumHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// IssueComment events
//
var issueCommentHandlers []func(context.Context, *github.IssueCommentEvent) error

// IssueCommentHandler registers a handler for IssueComment events.
func IssueCommentHandler(hndl func(context.Context, *github.IssueCommentEvent) error) {
	issueCommentHandlers = append(issueCommentHandlers, hndl)
}

// handleIssueComment calls all handlers for IssueComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssueComment(ctx context.Context, event *github.IssueCommentEvent) error {
	for _, hndl := range issueCommentHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Issues events
//
var issuesHandlers []func(context.Context, *github.IssuesEvent) error

// IssuesHandler registers a handler for Issues events.
func IssuesHandler(hndl func(context.Context, *github.IssuesEvent) error) {
	issuesHandlers = append(issuesHandlers, hndl)
}

// handleIssues calls all handlers for Issues events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleIssues(ctx context.Context, event *github.IssuesEvent) error {
	for _, hndl := range issuesHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Label events
//
var labelHandlers []func(context.Context, *github.LabelEvent) error

// LabelHandler registers a handler for Label events.
func LabelHandler(hndl func(context.Context, *github.LabelEvent) error) {
	labelHandlers = append(labelHandlers, hndl)
}

// handleLabel calls all handlers for Label events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleLabel(ctx context.Context, event *github.LabelEvent) error {
	for _, hndl := range labelHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Member events
//
var memberHandlers []func(context.Context, *github.MemberEvent) error

// MemberHandler registers a handler for Member events.
func MemberHandler(hndl func(context.Context, *github.MemberEvent) error) {
	memberHandlers = append(memberHandlers, hndl)
}

// handleMember calls all handlers for Member events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMember(ctx context.Context, event *github.MemberEvent) error {
	for _, hndl := range memberHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Membership events
//
var membershipHandlers []func(context.Context, *github.MembershipEvent) error

// MembershipHandler registers a handler for Membership events.
func MembershipHandler(hndl func(context.Context, *github.MembershipEvent) error) {
	membershipHandlers = append(membershipHandlers, hndl)
}

// handleMembership calls all handlers for Membership events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMembership(ctx context.Context, event *github.MembershipEvent) error {
	for _, hndl := range membershipHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Milestone events
//
var milestoneHandlers []func(context.Context, *github.MilestoneEvent) error

// MilestoneHandler registers a handler for Milestone events.
func MilestoneHandler(hndl func(context.Context, *github.MilestoneEvent) error) {
	milestoneHandlers = append(milestoneHandlers, hndl)
}

// handleMilestone calls all handlers for Milestone events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleMilestone(ctx context.Context, event *github.MilestoneEvent) error {
	for _, hndl := range milestoneHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// PageBuild events
//
var pageBuildHandlers []func(context.Context, *github.PageBuildEvent) error

// PageBuildHandler registers a handler for PageBuild events.
func PageBuildHandler(hndl func(context.Context, *github.PageBuildEvent) error) {
	pageBuildHandlers = append(pageBuildHandlers, hndl)
}

// handlePageBuild calls all handlers for PageBuild events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePageBuild(ctx context.Context, event *github.PageBuildEvent) error {
	for _, hndl := range pageBuildHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Public events
//
var publicHandlers []func(context.Context, *github.PublicEvent) error

// PublicHandler registers a handler for Public events.
func PublicHandler(hndl func(context.Context, *github.PublicEvent) error) {
	publicHandlers = append(publicHandlers, hndl)
}

// handlePublic calls all handlers for Public events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePublic(ctx context.Context, event *github.PublicEvent) error {
	for _, hndl := range publicHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// PullRequest events
//
var pullRequestHandlers []func(context.Context, *github.PullRequestEvent) error

// PullRequestHandler registers a handler for PullRequest events.
func PullRequestHandler(hndl func(context.Context, *github.PullRequestEvent) error) {
	pullRequestHandlers = append(pullRequestHandlers, hndl)
}

// handlePullRequest calls all handlers for PullRequest events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequest(ctx context.Context, event *github.PullRequestEvent) error {
	for _, hndl := range pullRequestHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// PullRequestReview events
//
var pullRequestReviewHandlers []func(context.Context, *github.PullRequestReviewEvent) error

// PullRequestReviewHandler registers a handler for PullRequestReview events.
func PullRequestReviewHandler(hndl func(context.Context, *github.PullRequestReviewEvent) error) {
	pullRequestReviewHandlers = append(pullRequestReviewHandlers, hndl)
}

// handlePullRequestReview calls all handlers for PullRequestReview events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReview(ctx context.Context, event *github.PullRequestReviewEvent) error {
	for _, hndl := range pullRequestReviewHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// PullRequestReviewComment events
//
var pullRequestReviewCommentHandlers []func(context.Context, *github.PullRequestReviewCommentEvent) error

// PullRequestReviewCommentHandler registers a handler for PullRequestReviewComment events.
func PullRequestReviewCommentHandler(hndl func(context.Context, *github.PullRequestReviewCommentEvent) error) {
	pullRequestReviewCommentHandlers = append(pullRequestReviewCommentHandlers, hndl)
}

// handlePullRequestReviewComment calls all handlers for PullRequestReviewComment events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePullRequestReviewComment(ctx context.Context, event *github.PullRequestReviewCommentEvent) error {
	for _, hndl := range pullRequestReviewCommentHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Push events
//
var pushHandlers []func(context.Context, *github.PushEvent) error

// PushHandler registers a handler for Push events.
func PushHandler(hndl func(context.Context, *github.PushEvent) error) {
	pushHandlers = append(pushHandlers, hndl)
}

// handlePush calls all handlers for Push events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handlePush(ctx context.Context, event *github.PushEvent) error {
	for _, hndl := range pushHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Release events
//
var releaseHandlers []func(context.Context, *github.ReleaseEvent) error

// ReleaseHandler registers a handler for Release events.
func ReleaseHandler(hndl func(context.Context, *github.ReleaseEvent) error) {
	releaseHandlers = append(releaseHandlers, hndl)
}

// handleRelease calls all handlers for Release events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRelease(ctx context.Context, event *github.ReleaseEvent) error {
	for _, hndl := range releaseHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Repository events
//
var repositoryHandlers []func(context.Context, *github.RepositoryEvent) error

// RepositoryHandler registers a handler for Repository events.
func RepositoryHandler(hndl func(context.Context, *github.RepositoryEvent) error) {
	repositoryHandlers = append(repositoryHandlers, hndl)
}

// handleRepository calls all handlers for Repository events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleRepository(ctx context.Context, event *github.RepositoryEvent) error {
	for _, hndl := range repositoryHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Status events
//
var statusHandlers []func(context.Context, *github.StatusEvent) error

// StatusHandler registers a handler for Status events.
func StatusHandler(hndl func(context.Context, *github.StatusEvent) error) {
	statusHandlers = append(statusHandlers, hndl)
}

// handleStatus calls all handlers for Status events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleStatus(ctx context.Context, event *github.StatusEvent) error {
	for _, hndl := range statusHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// TeamAdd events
//
var teamAddHandlers []func(context.Context, *github.TeamAddEvent) error

// TeamAddHandler registers a handler for TeamAdd events.
func TeamAddHandler(hndl func(context.Context, *github.TeamAddEvent) error) {
	teamAddHandlers = append(teamAddHandlers, hndl)
}

// handleTeamAdd calls all handlers for TeamAdd events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleTeamAdd(ctx context.Context, event *github.TeamAddEvent) error {
	for _, hndl := range teamAddHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}

//
// Watch events
//
var watchHandlers []func(context.Context, *github.WatchEvent) error

// WatchHandler registers a handler for Watch events.
func WatchHandler(hndl func(context.Context, *github.WatchEvent) error) {
	watchHandlers = append(watchHandlers, hndl)
}

// handleWatch calls all handlers for Watch events. If a handler
// returns an error, that error is returned immediately and no further handlers
// are called.
func handleWatch(ctx context.Context, event *github.WatchEvent) error {
	for _, hndl := range watchHandlers {
		if err := hndl(ctx, event); err != nil {
			return err
		}
	}

	return nil
}
